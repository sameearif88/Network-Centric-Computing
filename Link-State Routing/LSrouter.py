import sys
from collections import defaultdict
from router import Router
from packet import Packet
from json import dumps, loads
from dijkstar import Graph, find_path


class LSrouter(Router):
    """Link state routing protocol implementation."""

    def __init__(self, addr, heartbeatTime):
        """TODO: add your own class fields and initialization code here"""
        Router.__init__(self, addr)  # initialize superclass - don't remove
        self.heartbeatTime = heartbeatTime
        self.last_time = 0
        # Hints: initialize local state
        self.link_state = {} #APNA LINK STATE
        self.link_state_local = {} #BAKI SUB KA LINK STATE
        self.sequence_number = 0 #SEND KARTAY WAKT SEQ NUM
        self.check_sequence_number = {} #RECIEVE KARTAY WAKT SEQ NUM
        self.network_graph = Graph(undirected=True) #GRAPH
        self.forwarding_table = {} #FRWD TABLE


    def handlePacket(self, port, packet):
        """TODO: process incoming packet"""
        if packet.isTraceroute():
            # Hints: this is a normal data packet
            # if the forwarding table contains packet.dstAddr
            #   send packet based on forwarding table, e.g., self.send(port, packet)
            self.sendNormalPacket(packet)
        else:
            # Hints: this is a routing packet generated by your routing protocol
            # check the sequence number
            # if the sequence number is higher and the received link state is different
            #   update the local copy of the link state
            #   update the forwarding table
            #   broadcast the packet to other neighbors
            recieved_link_state, received_sequence_number = loads(packet.content)
            if packet.srcAddr not in self.check_sequence_number.keys():
                self.check_sequence_number[packet.srcAddr] = 0
            if self.check_sequence_number[packet.srcAddr] < int(received_sequence_number):
                if recieved_link_state not in self.link_state_local.values():
                    self.check_sequence_number[packet.srcAddr] = int(received_sequence_number)
                    self.updateNetworkGraph(packet, recieved_link_state)
                    self.updateForwardingTable()
                    self.forwardLinkState(packet, port)


    def updateNetworkGraph(self, packet, recieved_link_state):
        if packet.srcAddr in self.link_state_local.keys():
            for link in self.link_state_local[packet.srcAddr].values():
                if link[1] in self.network_graph[link[0]].keys():
                    self.network_graph.remove_edge(link[0], link[1])
        self.link_state_local[packet.srcAddr] = recieved_link_state
        for link in recieved_link_state.values():
            self.network_graph.add_edge(link[0], link[1], int(link[2]))


    def updateForwardingTable(self):
        self.forwarding_table.clear()
        for port_no, link in self.link_state.items():
            self.forwarding_table[link[1]] = (link[1], port_no)
        for link_state in self.link_state_local.values():
            for link in link_state.values():
                try:
                    path = find_path(self.network_graph, self.addr, link[1])
                    port = self.forwarding_table[path.nodes[1]][1]
                    self.forwarding_table[link[1]] = (path.nodes[1], port)
                except:
                    pass


    def forwardLinkState(self, packet, port):
        for port_no in self.link_state.keys():
            if port_no != port:
                self.send(port_no, packet)


    def sendNormalPacket(self, packet):
        if packet.dstAddr in self.forwarding_table.keys():
            port = self.forwarding_table[packet.dstAddr][1]
            self.send(port, packet)


    def forwardLinkState(self, packet, port):
        for port_no in self.link_state.keys():
            if port_no != port:
                self.send(port_no, packet)


    def handleNewLink(self, port, endpoint, cost):
        """TODO: handle new link"""
        # Hints:
        # update the forwarding table
        # broadcast the new link state of this router to all neighbors
        self.link_state[port] = (self.addr, endpoint, cost)
        self.network_graph.add_edge(self.addr, endpoint, cost)
        self.forwarding_table[endpoint] = (endpoint, port)
        self.sendLinkState()


    def sendLinkState(self):
        message_content = dumps([self.link_state, self.sequence_number])
        for port_no, link in self.link_state.items():
            send_packet = Packet(Packet.ROUTING, self.addr, link[1], content=message_content)
            self.send(port_no, send_packet)
        self.sequence_number += 1


    def handleRemoveLink(self, port):
        """TODO: handle removed link"""
        # Hints:
        # update the forwarding table
        # broadcast the new link state of this router to all neighbors
        link = self.link_state[port]
        del self.link_state[port]
        if link[1] in self.link_state_local.keys():
            del self.link_state_local[link[1]]
        self.network_graph.remove_edge(self.addr, link[1])
        self.updateForwardingTable()
        self.sendLinkState()


    def handleTime(self, timeMillisecs):
        """TODO: handle current time"""
        if timeMillisecs - self.last_time >= self.heartbeatTime:
            self.last_time = timeMillisecs
            # Hints:
            # broadcast the link state of this router to all neighbors
            self.sendLinkState()


    def debugString(self):
        """TODO: generate a string for debugging in network visualizer"""
        return ""
